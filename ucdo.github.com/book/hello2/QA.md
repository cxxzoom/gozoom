## 问题和答案
```
# 关于s[i,j] cap
    a := [13]int{}
    s := a[4,7]
    fmt.Println(len(s),cap(s)) // 3 9
    
    Q: 为什么这里输出的是cap(s) 为 9 ？
    A： 容量是从slice的第一个元素开始，原底层数组末尾的个数


# 关于slice 扩容
    Q: 如果我扩容的大小超过了make的时候指定的大小，底层数组会怎么样？ 我说说我的猜想，不对你帮我纠正一下；如果make创建slice，扩容的时候超过了指定cap的大小时，会重新创建一个匿名数组，然后这个slice的指针指向新的匿名数组的第一个元素？
     
    A:  
        你的猜想是正确的。当你向一个切片中追加元素，如果追加的元素导致切片长度超过它当前的容量时，Go 会自动进行所谓的“切片扩容”。
        
        这个过程要做的事情包括：
        
        1. 分配一个新的，更大的底层数组来容纳新的元素。这个新数组通常比当前数组大一定的比例，以减少每次追加操作引起的内存分配次数，从而优化性能。
        
        2. 复制原有数组中的元素到这个新数组里。
        
        3. 更新切片的指针，使其指向新数组的起始地址。
        
        这意味着，一旦扩容操作完成，原来的底层数组将被新的数组取代，旧的数组会在没有引用的情况下等待垃圾回收。扩容后的切片将像你所描述的那样工作，其指针指向新的底层数组的第一个元素。
        
        请注意，这种底层数组的替换和数据的复制过程对切片的使用者是透明的，使用者不需要关心背后的复制和扩容操作，他们只是简单地进行切片的追加或其他操作。
```